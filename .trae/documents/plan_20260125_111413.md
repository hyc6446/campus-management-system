## 问题分析

当前 `QueryPermissionDto` 字段获取不到的根本原因：

1. **Zod Schema 合并语法错误**：
   - 使用了扩展运算符 `...paginationSchema` 和 `...sortingSchema` 来合并 schema
   - 这在 Zod 中是不正确的用法，Zod 应该使用 `merge` 方法来合并 schema

2. **Transform 函数变量引用错误**：
   - Transform 函数中引用了未定义的变量 `data`
   - 应该引用 `sortingData` 变量

3. **Schema 结构问题**：
   - 由于合并方式错误，导致生成的 schema 结构不正确
   - 最终生成的 DTO 缺少相应的字段

## 修复方案

### 步骤 1：修复 QueryPermissionSchema 定义

修改 `src/modules/permission/dto/query-permission.dto.ts` 文件：

```typescript
import { createZodDto } from 'nestjs-zod'
import { paginationSchema, createSortingSchema } from '@app/common/validators/zod-validators'
import { PERMISSION_ALLOWED_SORT_FIELDS } from '@app/common/prisma-types';
import { z } from 'zod';

export const QueryPermissionSchema = paginationSchema
  .merge(
    z.object({
      // 筛选参数,支持多字段筛选
      id: z.coerce.number().int('权限ID必须是整数').optional().describe('权限ID'),
      action: z.string().optional().describe('动作'),
      subject: z.string().optional().describe('对象'),
      roleId: z.coerce.number().int('角色ID必须是整数').optional().describe('角色ID'),
      createdAt: z.union([z.string(), z.date()]).optional().describe('创建时间'),
    })
  )
  .merge(createSortingSchema(PERMISSION_ALLOWED_SORT_FIELDS))
  .transform((data) => {
    const sortStr = data.sortBy?.trim().toLowerCase() || 'createdAt';
    const orderStr = data.order?.trim().toLowerCase() || 'desc';
    const sortBy: string = PERMISSION_ALLOWED_SORT_FIELDS.includes(sortStr) ? sortStr : 'createdAt';
    const order: string = ['asc', 'desc'].includes(orderStr) ? orderStr : 'desc';
    return { ...data, sortBy, order };
  });

export class QueryPermissionDto extends createZodDto(QueryPermissionSchema) {}

export type QueryPermissionType = z.infer<typeof QueryPermissionSchema>;
```

### 步骤 2：验证修复效果

1. **类型检查**：确保 TypeScript 类型检查通过
2. **编译验证**：运行 `npm run build` 确保编译通过
3. **功能验证**：测试 `permission.service.ts` 是否能正确获取 DTO 字段

### 步骤 3：为其他模块提供参考实现

例如，用户模块的 DTO：

```typescript
import { createZodDto } from 'nestjs-zod'
import { paginationSchema, createSortingSchema } from '@app/common/validators/zod-validators'
import { USER_ALLOWED_SORT_FIELDS } from '@app/common/prisma-types';
import { z } from 'zod';

export const QueryUserSchema = paginationSchema
  .merge(
    z.object({
      // 筛选参数
      email: z.string().optional().describe('邮箱'),
      userName: z.string().optional().describe('用户名'),
    })
  )
  .merge(createSortingSchema(USER_ALLOWED_SORT_FIELDS))
  .transform((data) => {
    const sortStr = data.sortBy?.trim().toLowerCase() || 'createdAt';
    const orderStr = data.order?.trim().toLowerCase() || 'desc';
    const sortBy: string = USER_ALLOWED_SORT_FIELDS.includes(sortStr) ? sortStr : 'createdAt';
    const order: string = ['asc', 'desc'].includes(orderStr) ? orderStr : 'desc';
    return { ...data, sortBy, order };
  });

export class QueryUserDto extends createZodDto(QueryUserSchema) {}
```

## 技术说明

1. **Zod Schema 合并**：
   - 使用 `merge` 方法来合并 Zod schema
   - 这是 Zod 官方推荐的合并方式，确保类型安全

2. **Transform 函数**：
   - 修复了变量引用错误，使用 `data` 参数
   - 保持了原有的排序字段验证逻辑
   - 确保返回完整的 data 对象

3. **可扩展性**：
   - 使用 `createSortingSchema` 函数创建可配置的排序 schema
   - 每个模块可以自定义允许的排序字段
   - 保持了代码的复用性和一致性

4. **类型安全**：
   - 确保生成的 DTO 类型正确
   - 保持了 TypeScript 类型推断的准确性

## 优势

1. **修复字段获取问题**：确保 service 层能正确获取 DTO 中的所有字段
2. **代码复用**：保持了排序和分页逻辑的复用
3. **灵活性**：每个模块可以自定义允许的排序字段
4. **类型安全**：确保类型一致性
5. **可维护性**：修改排序逻辑只需要修改一个地方

此方案既解决了当前字段获取不到的问题，又提供了一个可扩展的模式来处理不同模块的排序需求。